Index: src/LexPython.cxx
===================================================================
--- src/LexPython.cxx	(revision 33720)
+++ src/LexPython.cxx	(working copy)
@@ -316,31 +316,35 @@
 }
 
 
 static void FoldPyDoc(unsigned int startPos, int length, int /*initStyle - unused*/,
                       WordList *[], Accessor &styler) {
 	const int maxPos = startPos + length;
 	const int maxLines = styler.GetLine(maxPos - 1);             // Requested last line
 	const int docLines = styler.GetLine(styler.Length() - 1);  // Available last line
 	const bool foldComment = styler.GetPropertyInt("fold.comment.python") != 0;
 	const bool foldQuotes = styler.GetPropertyInt("fold.quotes.python") != 0;
+	const bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
 
 	// Backtrack to previous non-blank line so we can determine indent level
 	// for any white space lines (needed esp. within triple quoted strings)
 	// and so we can fix any preceding fold level (which is why we go back
 	// at least one line in all cases)
 	int spaceFlags = 0;
 	int lineCurrent = styler.GetLine(startPos);
 	int indentCurrent = styler.IndentAmount(lineCurrent, &spaceFlags, NULL);
 	while (lineCurrent > 0) {
 		lineCurrent--;
 		indentCurrent = styler.IndentAmount(lineCurrent, &spaceFlags, NULL);
+		if (!foldCompact) {
+			indentCurrent &= ~SC_FOLDLEVELWHITEFLAG;
+		}
 		if (!(indentCurrent & SC_FOLDLEVELWHITEFLAG) &&
 		        (!IsCommentLine(lineCurrent, styler)) &&
 		        (!IsQuoteLine(lineCurrent, styler)))
 			break;
 	}
 	int indentCurrentLevel = indentCurrent & SC_FOLDLEVELNUMBERMASK;
 
 	// Set up initial loop state
 	startPos = styler.LineStart(lineCurrent);
 	int prev_state = SCE_P_DEFAULT & 31;
@@ -415,26 +419,34 @@
 		// Do this from end to start.  Once we encounter one line
 		// which is indented more than the line after the end of
 		// the comment-block, use the level of the block before
 
 		int skipLine = lineNext;
 		int skipLevel = levelAfterComments;
 
 		while (--skipLine > lineCurrent) {
 			int skipLineIndent = styler.IndentAmount(skipLine, &spaceFlags, NULL);
 
-			if ((skipLineIndent & SC_FOLDLEVELNUMBERMASK) > levelAfterComments)
-				skipLevel = levelBeforeComments;
-
-			int whiteFlag = skipLineIndent & SC_FOLDLEVELWHITEFLAG;
+			if (foldCompact) {
+                            	if ((skipLineIndent & SC_FOLDLEVELNUMBERMASK) > levelAfterComments)
+					skipLevel = levelBeforeComments;
+
+                            	int whiteFlag = skipLineIndent & SC_FOLDLEVELWHITEFLAG;
+                            	styler.SetLevel(skipLine, skipLevel | whiteFlag);
+                        } else {
+				if ((skipLineIndent & SC_FOLDLEVELNUMBERMASK) > levelAfterComments &&
+					!(skipLineIndent & SC_FOLDLEVELWHITEFLAG) &&
+					!IsCommentLine(skipLine, styler))
+					skipLevel = levelBeforeComments;
 
-			styler.SetLevel(skipLine, skipLevel | whiteFlag);
+				styler.SetLevel(skipLine, skipLevel);
+			}
 		}
 
 		// Set fold header on non-quote/non-comment line
 		if (!quote && !comment && !(indentCurrent & SC_FOLDLEVELWHITEFLAG) ) {
 			if ((indentCurrent & SC_FOLDLEVELNUMBERMASK) < (indentNext & SC_FOLDLEVELNUMBERMASK))
 				lev |= SC_FOLDLEVELHEADERFLAG;
 		}
 
 		// Keep track of triple quote and block comment state of previous line
 		prevQuote = quote;
